---
title:  "백준 15989. 1, 2, 3 더하기 4"
excerpt: "https://www.acmicpc.net/problem/15989"
categories:
  - Algorithm
tags:
  - Algorithm
  - BOJ
  - 백준
  - acmicpc
last_modified_at: 2021-04-24
sitemap :
    changefreq : daily
    priority : 1.0
toc: true
---
## [15989. 1, 2, 3 더하기 4](https://www.acmicpc.net/problem/15989)
### 문제 요약
- 다이나믹 프로그래밍 문제
- 주어진 수를 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제이다.
- 수를 구하는 과정에서 **순서만 다른 경우는 같은것으로 체크**한다.(중복을 허용하지 않는다)
- 예를 들어 정수 4를 1, 2, 3으로 나타내는 경우 아래 세가지는 한가지로 체크한다.
  - 1 + 1 + 2
  - 1 + 2 + 1
  - 2 + 1 + 1

### 풀이 방법
- 수를 나열할때는 **오름차순으로 나열**하여 중복을 제거한다.
- 점화식, 초기값, 계산식을 아래처럼 구하였다.
1. `d[i][j]` : 합이 `i`인 수 중 `j`를 마지막으로 더한 경우의 수
2. 초기값

```
d[1][1] = 1; // 1
d[1][2] = 0; // 없음
d[1][3] = 0; // 없음

d[2][1] = 1; // 1 + 1
d[2][2] = 1; // 2
d[2][3] = 0; // 없음

d[3][1] = 1; // 1 + 1 + 1
d[3][2] = 1; // 1 + 2 (또는 2 + 1 인데 중복)
d[3][3] = 1; // 3
```

1. 오름차순으로 나열하는것에 주의하며 `bottom - up`으로 계산한다.
- 1로 끝난 경우    :  바로 앞에 더한 수는 1만 나올 수 있다.
- 2로 끝난 경우    :  바로 앞에 더한 수가 1, 2가 나올 수 있다
- 3으로 끝난 경우  :  바로 앞에 더한 수가 1, 2, 3이 나올 수 있다.

### 소스 코드

```cpp
#include<iostream>

using namespace std;

int d[10001][4];
int main()
{
    int t;
    cin >> t;

    d[1][1] = 1; // 1
    d[1][2] = 0; // 없음
    d[1][3] = 0; // 없음

    d[2][1] = 1; // 1 + 1
    d[2][2] = 1; // 2
    d[2][3] = 0; // 없음

    d[3][1] = 1; // 1 + 1 + 1
    d[3][2] = 1; // 2 + 1 (또는 1 + 2 인데 중복)
    d[3][3] = 1; // 3

    for (int i = 4; i <= 10000; i++)
    {
        d[i][1] = d[i - 1][1];
        d[i][2] = d[i - 2][1] + d[i - 2][2];
        d[i][3] = d[i - 3][1] + d[i - 3][2] + d[i - 3][3];
    }

    int k;
    while (t-- > 0)
    {
        cin >> k;
        cout << d[k][1] + d[k][2] + d[k][3] << "\n";
    }
    return 0;
}
```

### [전체 소스 코드](https://github.com/tdm1223/Algorithm/blob/master/acmicpc.net/source/15989.cpp)