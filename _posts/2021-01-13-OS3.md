---
title:  "프로세스"
excerpt: "프로세스의 상태, 프로세스 종류, PCB, 스케줄러"
categories:
  - OperatingSystem
tags:
  - OperatingSystem
  - process
  - pcb
  - scheduler
  - process state
last_modified_at: 2021-01-13T00:00:50-00:00
sitemap :
    changefreq : daily
    priority : 1.0
toc: true
---

## 프로세스
- 실행 중인 프로그램. 프로그램 실행의 단위. 
- 프로세스 실행은 순차적으로 진행되어야 한다.
- 프로세스는 프로그램 카운터(PC), 스택(Stack), 데이터 섹션을 포함한다.

## 프로세스 상태 (Process State)
![ProcessState](/img/ProcessState.jpg)
1. new : 프로세스가 **생성**된 상태. 
2. ready : 프로세스가 CPU에 할당받기 **대기** 중인 상태. 
3. running : 프로세스가 **실행** 중인 상태. 
4. waiting : 프로세스가 I/O Operation 등 특정 event 발생으로 **대기** 중인 상태. ( 또는 sleep함수 ) 
5. terminated : 프로세스가 실행을 **마친** 상태. 

### waiting과 ready 상태의 차이점
- `waiting`은 disk, I/O 등으로 **절대 프로세스가 실행될 수 없는 상태**이며, `ready`는 CPU에 할당받기를 대기 중인 상태로, 프로세스가 수행될 수 있는 상태이다. 
- `waiting`상태에 들어간 프로세스는 특정 event가 종료되면, `running`이 아닌 `ready` 상태로 전환된다.

## Process Control Block (프로세스 제어 블록, PCB)
![PCB](/img/PCB.jpg)
- 구조체 변수로써 프로세스에 대한 **모든 정보**를 담고 있다. 
- 프로세스와 관련된 정보 
1. 프로세스 상태 
2. 프로그램 카운터 
3. CPU 레지스터 
4. CPU 예약 정보 
5. 메모리 관리 정보 
6. counting 정보 
7. I / O 상태 정보

## 프로세스의 종류
- I/O-bound 프로세스 : 연산은 적지만 I/O 수행 시간이 많은 프로세스, 예로 워드프로세서가 있다. 
- CPU-bound 프로세스 : CPU 연산량이 많은 프로세스로, 예로 영화가 있다. 
- 일반적으로 Scheduler의 우선순위는 I/O-bound process가 더 높다. **CPU 연산량이 적기 때문**이다.

## Context Switch(문맥 교환)
![ContextSwitch](/img/ContextSwitch.jpg)
- CPU가 다른 프로세스로 전환하면 시스템은 이전 프로세스의 상태를 저장하고 새 프로세스에 대해 저장된 상태를 불러온다. 
- 문맥 교환 시간은 **하드웨어**에 의존한다. 
- 문맥을 교환하는 동안에는 유용한 작업을 수행할 수 없기 때문에, 문맥 교환 시간은  
  일종의 **오버헤드**라고 할 수 있다.

## Process Scheduling Queue
1. Job queue
  - 시스템에서 **실행 중인 프로세스**들이 들어가는 큐로, 현재 메모리에 올라가 있는 모든 프로세스들이 들어간다. 
2. Ready queue
  - 메인 메모리 내에서 CPU에게 **할당받기를 대기하고 있는 프로세스**들이 들어가는 큐로, Ready 상태의 Process들이 Ready queue로 들어간다.
Scheduler는 Ready queue를 보고 가장 우선순위가 높은 task를 선택한다.
3. Device queue
  - **I/O device를 기다리고 있는** 큐
  - 여러 개의 프로세스가 I/O 요청을 보냈을 수도 있기 때문에 따로 큐가 존재한다.

## Scheduler
1. Long-term Scheduler
  - 어떤 프로세스가 **ready queue(메모리)로 할당**이 될지를 선택해 주는 Scheduler 
  - 요즘 컴퓨터들은 성능이 좋기 때문에 매우 드물게 일어나거나 아예 일어나지 않는다. 
  - 메모리 내에서 현재 수행 중인 프로그램의 개수를 제어하며, 시스템의 안정성을 결정한다. 
  - 프로세스가 많아지면 안정을 시켜준다. 
2. Mid-term Scheduler
  - **가상 메모리**와 **메인 메모리** 사이를 관리해주는 Scheduler 
  - 누구를 Swapping-in 하고 누구를 Swapping-out 할지 결정해주는 Scheduler 
3. Short-term Scheduler
  - 10밀리 세컨드(Timer interrupt)마다 발동되어 **CPU에 할당될 프로세스**를 결정해 주는 Scheduler 
  - 매우 자주 발생한다.

## 프로세스 생성(Process Creation)
- 부모 프로세스는 자식 프로세스를 생성한다. 
- 기존의 프로세스가 새로운 프로세스를 생성을 한다. 
- 프로세스들의 구조는 **트리** 형태로 나타난다. 
- 자원 공유 : 자식 프로세스는 부모 프로세스의 자원을 공유한다. 
- 실행 : 자식과 부모 프로세스는 별도의 프로세스로써 실행된다. 부모 프로세스는 자식 프로세스가 종료될 때까지 기다린다. 
- 주소 공간 : 자식 프로세스는 부모 프로세스의 주소 공간을 복제한다. 자식 프로세스는 새로운 프로그램을 받아온다.

### UNIX / Linux에서의 프로세스 생성
![UNIXandLINUX](/img/UNIXandLINUX.jpg)
- 유닉스 계열의 OS는 시스템이 부팅할 때 0번 프로세스만 생성하고 나머지 프로세스는 복제라는 기법을 사용한다. 
- `fork()` : 새로운 프로세스를 생성하는 시스템 콜 함수 (복제하는 역할) 
- `exec()` : 프로세스의 메모리 공간을 새로운 프로그램으로 대체하기 위해 fork 후에 사용되는 시스템 호출 
- 부모와 자식 프로세스는 공유 파일을 갖지만, CPU time이나 메모리는 공유되지 않는다. 
- 부모와 자식 프로세스는 동시에 실행된다. 
- 주소 공간을 복제하긴 하지만, **별도의 주소 공간**을 갖는다.

## 프로세스 종료(Process Termination)
- 프로세스는 마지막 명령문을 실행하고 운영체제에 명령문을 삭제하도록 요청한다. (exit) 
- 자식에서 부모로 데이터를 출력한다. (wait) 
- 프로세스의 자원이 운영체제에 의해 할당 해제된다. 
- 부모 프로세스는 자식 프로세스의 실행을 종료할 수 있다. (abort) 
- exit() 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면 종료한다. 
- 프로세스는 자신의 부모 프로세스에게 상태 값을 반환할 수 있다. 
- 프로세스의 모든 자원이 운영체제로 반납된다.

## 프로세스 간 통신
- **독립 프로세스**는 다른 프로세스의 실행에 영향을 미치거나 영향을 받을 수 없다. 
- **협력 프로세스**는 다른 프로세스의 실행에 영향을 주거나 영향을 받을 수 있다.

## 프로세스 협력의 이점
1. 정보 공유 
2. 계산속도 향상 
3. 모듈성 
4. 편리함