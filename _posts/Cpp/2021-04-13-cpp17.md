---
title: "예외 처리"
excerpt: "C++에서 제공하는 예외 처리"
categories:
  - cpp
tags:
  - cpp
  - 예외
  - 예외 처리
  - 예외 던지기
  - try
  - throw
  - catch
  - expn
  - throw(...)
last_modified_at: 2021-04-13T08:00:20-00:00
sitemap :
    changefreq : daily
    priority : 1.0
toc: true
---
## 예외란?
- 문법적인 오류가 아닌 **프로그램의 논리에 맞지 않는 상황**을 의미한다.

## 예외상황과 예외처리의 이해

### 예외 상황의 예
- 나이를 입력하라고 했는데 0보다 작은 값이 입력되었다.
- 나눗셈을 위한 두 개의 정수를 입력받는데 제수로 0이 입력되었다.

### C++에서 기본적인 예외처리
- `if`문으로 처리한다.

### if문으로 처리하는 것의 단점
1. 예외처리를 위한 코드와 프로그램의 흐름을 구성하는 코드를 쉽게 구분하지 못한다.
2. 주석처리를 해도 예외 처리인 것을 바로 판단하기는 힘들다.

## C++의 예외처리 메커니즘
1. `try` : 예외를 발견한다.
2. `catch` : 예외를 잡는다.
3. `throw` : 예외를 던진다.

```cpp
try
{
    if(예외가 발생한다면) 
    {
        throw expn // 예외 발생 예상 지역
    }
    // 예외가 발생하지 않았을 때 처리
}
catch(type expn) //처리할 예외의 종류 명시
{
    // 예외처리 코드의 삽입
}
```

- `try`와 `catch`는 하나의 문장이다. 항상 이어서 등장해야 하며 중간에 다른 문장이 오면 안 된다.
- `try`블록 내에서 예외가 발생하면 예외가 발생한 지점 이후의 나머지 `try`영역은 건너뛴다. (실행되지 않는다.)

### throw expn
- `expn`은 변수, 상수, 객체 등 표현 가능한 모든 데이터가 될 수 있으나 예외상황에 대한 정보를 담은 의미 있는 **데이터**여야 한다.
- `throw`에 의해 던져진 예외 데이터는 예외 데이터를 감싸는 `try`블록에 의해서 감지가 된다.
- `catch`블록에 의해 처리된다.

```cpp
try
{
    if(num2==0)
    {
        throw num2;
    }
    cout<<"몫 : "<<num1/num2<<" 나머지 : "<<num1%num2<<endl;
}
catch (int expn)
{
    cout<<"제수는" <<expn<<이 될 수 없습니다.<<endl;
}
```

### try블록을 묶는 기준
1. `try`블록을 만나면 그 안에 삽입된 문장이 순서대로 실행된다.
2. `try`블록 내에서 예외가 발생하지 않으면 `catch`블록 이후를 실행한다.
3. `try`블록 내에서 예외가 발생하면 예외가 발생한 지점 이후의 나머지 `try`영역은 건너뛴다.
4. 예외가 발생할만한 영역만 묶는 게 아니라 관련된 모든 문장을 하나의 일 단위로 구성한다.

## 스택 풀기(Stack Unwinding)
- `throw`절에 의해서 예외가 발생은 했는데 처리되지 않아서 함수를 호출한 영역으로 예외 데이터가 전달되는 현상이다.
- 예외가 발생한 위치와 예외를 처리해야 하는 위치가 달라야만 하는 경우에 유용하다.
- `main`함수에서조차 예외를 처리하지 않으면 `terminate`함수가 호출되면서 프로그램이 종료된다.
- 함수 내에서 함수를 호출한 영역으로 예외 데이터를 전달하면 해당 함수는 더 이상 실행되지 않고 종료가 된다.
- 자료형이 일치하지 않아도 예외 데이터는 전달이 된다.
- 자료형의 불일치로 인해서 예외는 처리되지 않는다.(`catch` 블록으로 값이 전달되지 않는다.)

### 하나의 try 블록 와 다수의 catch블록
- 하나의 `try`블록 내에서 유형이 다른 둘 이상의 예외상황이 발생할 수도 있다.
- 각각의 예외를 표현하기 위해 사용되는 예외 데이터의 자료형이 다를 수 있다.
- 따라서 `try`블록에 이어서 등장하는 `catch`블록은 둘 이상이 될 수 있다.

### 전달되는 예외의 명시
```cpp
int ThrowFunc(int num) throw(int , char)
{

}
```

- `throw`선언은 함수 내에서 예외상황의 발생으로 인하여 `int`형 예외 데이터와 `char`형 예외 데이터가 전달될 수 있음을 알린다.
- 명시된 예외 데이터만이 전달되어야 하고 다른 예외 데이터가 전달될 경우 `terminate`함수의 호출로 인해 프로그램은 종료된다.
- 프로그래머의 **실수를 발견**하고 예외의 유형을 **정확히 점검**하도록 유도할 수 있다.

### 전달되는 예외를 비움
```cpp
int SimpleFunc() throw() {}
```

- 어떠한 예외도 전달하지 않음을 의미한다.
- 예외를 전달할 경우 프로그램은 종료가 된다.

## 예외상황을 표현하는 예외 클래스의 설계
### 예외 클래스
- 예외 발생을 알리는 데 사용되는 객체를 가리켜 예외 객체라 한다.
- 예외 객체의 생성을 위해 정의된 클래스를 **예외 클래스**라 한다.

```cpp
class DepositException
{
private:
    int reqDep; // 요청 입금액
public:
    DepositException(int money) : reqDep(money) { }
    void ShowExceptionReason()
    {
        cout<<reqDep<<"는 입금 불가"<<endl;
    }
};

void Deposit(int money) throw (DepositException)
{
    if(money<0)
    {
        DepositException expn(money);
        throw expn;
    }
    // 정상 작업
}
```

### 상속관계에 있는 예외 클래스
- 예외 클래스를 상속의 관계로 묶어놓으면 예외의 처리를 단순화할 수 있다.

- `Base` <- `Derived1` / `Base` <- `Derived2`일때
  - `catch(Derived1 &expn)`을 `catch(Base &expn)`으로 단순화 가능하다.
  - `catch(Derived2 &expn)`을 `catch(Base &expn)`으로 단순화 가능하다.

### 예외의 전달 방식에 따른 주의사항
- 예외가 발생하면 해당 예외 데이터를 전달받을 수 있는 `catch`블록을 위에서 아래로 찾아내려 간다.
- 적절한 `catch`블록을 찾게 되면 해당 `catch`블록이 실행되면서 예외의 처리는 완료가 된다.
- A <- B <- C의 상속 구조일 때 `catch`문을 C -> B -> A 순으로 작성해야 원하는 결과를 얻을 수 있다.

## 예외처리와 관련된 또 다른 특성들
### new 연산자에 의해서 발생하는 예외
- `new`연산에 의한 메모리 공간의 할당이 실패하면 `bad_alloc`이라는 예외가 발생한다.
- `bad_alloc`은 헤더 파일 `new`에 선언된 예외 클래스로써 메모리 공간의 할당이 실패했음을 알리는 의도로 정의되었다.

### 모든 예외를 처리하는 catch 블록
- `catch(...)`으로 선언하면 된다.

### 예외 던지기
- `catch`블록에 전달된 예외는 다시 던져질 수 있다.
- 하나의 예외가 둘 이상의 `catch`블록에 의해서 처리되게 할 수 있다.
- 필요한 상황이 아니라면 예외를 다시 던질 필요는 없다.