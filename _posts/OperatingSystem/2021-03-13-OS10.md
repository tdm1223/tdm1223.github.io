---
title:  "메모리 단편화"
excerpt: "단편화, 페이징, 세그멘테이션, 메모리풀"
categories:
  - OperatingSystem
tags:
  - OperatingSystem
  - 단편화
  - 페이징
  - 세그멘테이션
  - 메모리풀
  - segmentation
  - fragmentation
  - paging
  - memory pool
last_modified_at: 2021-03-13T02:00:50-00:00
sitemap :
    changefreq : daily
    priority : 1.0
toc: true
---

## 단편화 (Fragmentation)
- `RAM`에서 메모리의 공간이 작은 조각으로 나뉘어 **사용 가능한 메모리가 충분하지만 할당(사용)이 불가능한 상태**이다.

### 외부 단편화 (External Fragmentation)
- 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 존재하게된다.
- 새로운 프로세스가 할당될 **메모리 공간은 만족**하나 메모리 공간이 **연속적이지 않아 발생**한다.
- `Hole`들이 분산되어 저장되어 있기 때문에 발생한다.
- 압축과 가비지 컬렉션을 통해서 외부 단편화를 줄일 수 있다.
- 압축은 다수의 비어있는 `Hole`들을 합쳐서 하나의 큰 블록으로 만들어 주는 기법이다.
- 압축은 재할당이 동적일 때와 실행 시간에만 가능하다.

### 내부 단편화 (Internal Fragmentation)
- 최소 단위의 문제로 인하여 작은 공간이 발생하는 데, 이 공간이 사용되지 않는 현상을 **내부 단편화**라고 한다.
- `4KB`의 `page`를 예로 들면 `page`의 단위는 `4KB`인데, `3KB`만 사용하는 경우 `1KB`의 **내부 단편화**가 발생한 것이다.

## 단편화의 해결책
### 페이징 (Paging)
- 프레임 : **물리 메모리**를 일정한 크기로 나눈 블록
- 페이지 : **가상 메모리**를 일정한 크기로 나눈 블록
- 프레임과 페이지를 대응하게 하여 **연속적인 물리 메모리가 아니더라도 원하는 크기의 프레임을 사용할 수 있도록 한다.**
- 물리 메모리(프레임)와 가상 메모리(페이지)를 대응하기 위해 `page mapping` 과정이 필요한데, 이를 위해 페이징 테이블을 만든다.
- 연속적이지 않은 공간도 활용할 수 있기 때문에 **외부 단편화를 해결**할 수 있다.
- 코드를 쉽게 공유할 수 있다는 장점이 있다.
- 페이지 단위에 알맞게 꽉 채워 쓰는 게 아니므로 **내부 단편화 문제는 여전히 존재**한다.
- 페이지 단위를 작게 하면 내부 단편화 역시 해결할 수 있지만 (페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에) 그만큼 `page mapping` 과정이 증가하므로 오히려 효율이 떨어질 수 있다.

### 세그멘테이션 (Segmentation)
- **가상 메모리**를 서로 크기가 다른 **논리적 단위인 세그먼트로 분할**하고 메모리를 할당하며 주소 변환을 한다.
- 세그먼트는 연속적인 공간에 저장되어 있다.
- 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다.
- 페이징 기법과 마찬가지로 `mapping`을 위해 세그먼트 테이블을 필요로 한다.
- 세그먼트 단위로 통제가 가능한 장점이 있다.
- **서로 다른 크기의 세그먼트**들에 대해 필요시에 메모리에 올리고 필요 없을 경우 내리는 작업을 반복하다 보면 외부 단편화가 생긴다.

### 메모리 풀(Memory Pool)
- 메모리 공간을 필요한 만큼 사용자가 지정하여 할당 받아 놓고 필요할 때마다 사용, 반납하는 기법
- 동적 할당과 해제를 반복하면 메모리의 **랜덤한 위치에 할당과 해제가 반복**되면서 **단편화**를 일으킬 수 있다.
  - 메모리 할당 후 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 **외부 단편화**가 발생하지 않는다.
  - 필요한 만큼 할당을 해놓기 때문에 **내부 단편화**도 생기지 않는다.
- 메모리의 할당, 해제가 잦은 경우에 효과적이다.
- 사용하지 않는 순간에도 계속 할당해 놓으므로 **메모리 누수**가 있다.
- 구현 방법
  1. 큰 메모리 블록(페이지)을 힙으로부터 할당
  2. 할당받은 블록(페이지)을 각 객체의 크기의 블록으로 나눈다.
  3. 객체를 위한 블록을 순차적으로 링크한다.
  4. 할당할 블록을 특정 포인터가 가리키게 한다.
  5. 메모리 요청이 생기면 현재 헤더 포인터가 가리키는 블록을 돌려준다.
  6. 할당이 일어난 후 헤더 포인터는 할당 전에 가리키던 블록이 가리키던 블록을 가리킨다.
  7. 사용되던 메모리가 해제되어 메모리 풀로 돌아올 경우 헤더 포인터는 그 블록을 가리키고 방금 전까지 헤더 포인터가 가리키던 블록을 돌아온 블록의 다음 포인터가 가리키게 한다.