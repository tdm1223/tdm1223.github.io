---
title:  "CPU 스케줄링"
excerpt: "CPU 스케줄링에 대해 정리하는 포스트"
categories:
  - OperatingSystem
tags:
  - OperatingSystem
  - CPU 스케줄링
  - priority
  - Round Robin
  - Shortest-Job-First
  - Shortest-Remaining-Time-First
  - Highest REsponse Ration Next
  - Multilevel Feedback Queue
last_modified_at: 2021-02-10T02:00:50-00:00
sitemap :
    changefreq : daily
    priority : 1.0
toc: true
---

## CPU 스케줄링
- 실행 준비가 된 메모리의 프로세스 중에서 선택하고 그중 하나에게 `CPU`를 할당한다.
- `CPU` 스케줄링 결정은 프로세스가 다음과 같은 상황일 때 발생할 수 있다.
1. 실행 상태(running)에서 준비 상태(ready)로 전환 (인터럽트 발생)
2. 대기 상태(waiting)에서 준비 상태(ready)로 전환 (입출력 완료)
3. 신규 상태(new)에서 실행 상태(running)로 변할 경우
4. 실행 상태(running)에서 대기 상태(waiting)로 전환 (입출력 요청, wait)
5. 종료됨(terminated)

## 선점형과 비선점형 스케줄링
### 선점형 스케줄링
- 우선순위가 더 높은 프로세스가 도착할 때 실행 중인 프로세스는 실행을 멈추고 `CPU` 사용을 넘겨준다.
- 선점 스케줄링은 공유 자료를 접근하는 경우 비용을 유발한다.
- 대부분의 운영체제들은 문맥 교환을 실행하기 전에 시스템 호출의 완료 혹은 입출력 봉쇄를 기다림으로 문제를 해결한다.

### 비선점형 스케줄링
- 비선점 스케줄링에서는 `CPU`가 할당되면, 프로세스가 종료하거나 대기 상태로 전환해 `CPU`를 방출할 때까지 `CPU`를 점유한다.

## 완벽한 CPU 스케줄러의 목표
### 스케줄링 기준
1. CPU 사용률(CPU utilization) : 가능한 한 CPU를 바쁘게 유지한다.
2. 처리량(throughput) : 시간 단위 당 실행을 완료 한 프로세스 수
3. 처리 시간(turnaround time) : 특정 프로세스를 실행하는 데 걸리는 시간
4. 대기 시간(waiting time) : 프로세스가 준비 대기 열에서 대기 한 시간
5. 응답 시간(response time) : 요청이 제출된 후 첫 번째 응답이 생성되고 출력되지 않을 때까지 소요되는 시간

### 최소 응답 시간(min response time) / 소요 시간(turnaround time)
- 응답 시간은 사용자가 보는 시간이다.
- 키 스트로크에서 편집기까지 (수용 가능한 지연 ~ 50-150 밀리 초) 반복되는 경과 시간

### 최대 처리량
- 오버 헤드 최소화 (context switching)
- 자원 (CPU, 디스크, 캐시 등)의 효율적인 사용

### 공평성
- 모두가 진행하고 누구도 굶주리지 않는다.
- 불공평은 시스템을 더 빠르게 만든다.

### 최대 CPU 사용률

## 스케줄링 방법
### 1. Priority 스케줄링(우선순위 기법)
- 우선순위는 각 프로세스와 연관된다.
- `CPU`는 가장 높은 우선순위를 갖는 프로세스에 할당된다.
- 기아현상(우선순위가 낮은 프로세스는 절대로 실행될 수 없는 상황)이 발생할 수 있다
  - 해결책 : `Aging`(시간이 갈수록 프로세스의 우선순위가 높아진다.)

### 2. First Come First Served (FCFS 또는 FIFO)
- 가장 간단한 **비선점 기법** 스케줄링 알고리즘이다.
- 레디 큐(ready queue)에 도착한 순서대로 실행한다.
- Uni-programming : 완료될 때까지 실행
- Multi-programming : I/O 블록이 대기열에 있을 때 작업 대기열에 넣는다.
- 구현이 간단하다.
- 대기 시간은 도착 순서에 따라 다르다.
- 늦게 온 작업에게 불공평하다. (최악의 경우 : 가장 긴 잡이 가장 먼저 도착함)

```
P1 = 24, P2 = 3, P3 = 3일 때
P1, P2, P3 순으로 도착 시 대기시간이 P1 = 0, P2 = 24, P3 = 27이고 평균은 17이 된다.
P2, P3, P1 순으로 도착 시 대기시간이 P1 = 6, P2 = 0, P3 = 0이고 평균은 3이 된다.
```

### 3. Round Robin (RR)
- 각 프로세스는 CPU 시간의 작은 단위를 가져온다. (**선점 기법**)
- 이 시간이 경과하면 프로세스가 선점되고 준비 대기열의 끝에 추가된다.
- 대기열에 n개의 프로세스가 있고 `time slice`가 `q`인 경우 각 프로세스는 최대 `q`시간 단위의 덩어리로 `CPU` 시간의 `1/n`을 한 번에 가져온다.
- 어떤 프로세스도 `(n-1) q` 시간 단위를 기다리지 않게 된다.
- 일반적으로 SJF보다 평균 처리 횟수가 높지만 응답성이 우수하다.
- 타임 슬라이스 시간에 따른 성능
  1. 너무 높게 설정 한다면? 
    - `FIFO` 방식과 같다.
  2. 너무 낮게 설정 한다면? 
    - `Thread` 간에 `Context switching` 하는 데 모든 시간을 소비하게 된다.

- `Context switching`이 너무 자주 일어나지 않고 모든 생산성을 잃지 않는 한 `Context switching`은 일반적으로 무시할 수 있다.

time slice = 20이고 P1 = 53, P2 = 17, P3 = 68, P4 = 24일 때

![os8-1](/img/os8-1.jpg)

### 4. Shortest-Job-First(SJR) 스케줄링
- **선점 기법**을 활용한 **최단 완료 시간 알고리즘**이다.
- 각 프로세스와 다음 `CPU bursts`의 길이를 연관시킨다. 이 길이를 사용하여 최단 시간으로 프로세스를 예약한다.
- 두 가지 경우 존재
1. 비선점 : 일단 CPU가 프로세스에 주어지면 `CPU bursts`를 완료할 때까지 선점할 수 없다.
2. 선점 : 새 프로세스가 현재 실행 중인 프로세스의 남은 시간보다 작은 `CPU bursts`로 도착하면 선점한다.

### 5. Shortest-Remaining-Time-First (SRTF)
- 최적이다.
- 주어진 프로세스 집합에 대해 최소 평균 대기시간을 제공한다.
- 미래를 예측하기 힘들다.
- 불공정하다.

```
도착시간이 P1 = 0, P2 = 2, P3 = 4, P4 = 5이고 
Burst Time이 P1 = 7, P2 = 4, P3 = 1, P4 = 4라면

선점형일 때(Shortest Remaining Time 기법이라고도 한다.)
평균 대기시간은 (9+1+0+2)/4=3이다.

비선점형일 때
평균 대기시간은 (0+6+3+7)/4=4이다.
```

### 6. Highest Response Ratio Next(HRN) 기법
- SJF 스케줄링 기법의 약점인 긴 작업과 짧은 작업의 지나친 불평등을 보완한 스케줄링 기법이다.
- **비선점형 스케줄링 기법**이다.
- 서비스받을 시간이 분모에 있으므로 짧은 작업의 **우선순위**가 높아진다.
- 대기 시간이 분자에 있으므로 긴 작업도 대기 시간이 큰 경우에는 우선순위가 높아진다.

```
대기시간이 P1 = 0 , P2 = 2, P3 = 4이고 서비스 시간이 P1 = 10, P2 = 4, P3 = 9일 때
P1 우선순위 : (0+10)/10 = 1
P2 우선순위 : (2+4)/4 = 1.5
P3 우선순위 : (4+9)/9 = 1.4
우선순위는 P2 -> P3 -> P1 순이다.
```

### 7. Multilevel Feedback Queue(다중 레벨 피드백 큐)
- 프로세스가 여러 대기열 사이를 이동할 수 있다. `Aging`은 이런 식으로 구현될 수 있다.
- 다중 레벨 피드백 큐 스케줄러는 다음의 매개 변수로 정의된다.
1. 대기열 수
2. 각 큐에 대한 스케줄링 알고리즘
3. 프로세스를 업그레이드할 시기를 결정하는 데 사용되는 함수
4. 프로세스를 강등할 시기를 결정하는 데 사용되는 함수
5. 프로세스가 서비스를 필요로 할 때 프로세스가 입력할 큐를 결정하는 데 사용되는 함수

- Multilevel Feedback Queue의 예
  - Q1. RR (time quantum = 8)
  - Q2. RR (time quantum = 16)
  - Q3. FCFS